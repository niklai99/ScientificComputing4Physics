#!/usr/bin/env python3
"""
Compute integrals using Python and compare them with C++ results.

This script:
  - Loads output data from the C++ program (covering 0 to π).
  - Extracts the subset corresponding to the integration interval [0, π/2].
  - Computes the integral over [0, π/2] using the trapezoidal rule, Simpson’s rule, and Romberg integration.
  - Loads the corresponding C++ integral results from files.
  - Computes and prints the absolute differences.

Usage:
    ./compute_integral.py --N <N_value> --precision <precision_value>
Example:
    ./compute_integral.py --N 1048577 --precision 16
"""

import argparse
import numpy as np
from scipy.interpolate import interp1d
from scipy.integrate import trapezoid, simpson

# ============================
# Constants
# ============================
DATA_DIR = "./data"
# The data file is expected to be named as: data_<N>.txt (where N is the sample count used in C++).
OUTPUT_FILE_TEMPLATE = f"{DATA_DIR}/data_{{N}}.txt"

# Integration bounds (matching C++ integration interval)
A = 0.0
B = np.pi / 2.0

# Romberg integration parameters
ROMBERG_TOL = 1e-12
ROMBERG_RTOL = 1e-12
ROMBERG_DIVMAX = 20

# Print output precision
PRINT_PRECISION = 16
# Analytic solution for comparison.
ANALYTIC_SOLUTION = (np.exp(np.pi / 2.0) - 1.0) / 2.0

# ============================
# Romberg integration function
# ============================
def romberg(f, a, b, tol=ROMBERG_TOL, rtol=ROMBERG_RTOL, divmax=ROMBERG_DIVMAX):
    """
    Compute the Romberg integration of function f on the interval [a, b]
    using the trapezoidal rule and Richardson extrapolation.
    """
    R = []  # Romberg table: a list of lists
    R.append([(b - a) * (f(a) + f(b)) / 2.0])
    for i in range(1, divmax):
        n_intervals = 2**i
        h = (b - a) / n_intervals
        sum_ = 0.0
        for k in range(1, n_intervals, 2):
            sum_ += f(a + k * h)
        R0 = 0.5 * R[i-1][0] + h * sum_
        row = [R0]
        for j in range(1, i+1):
            factor = 4**j
            extrap = row[j-1] + (row[j-1] - R[i-1][j-1]) / (factor - 1.0)
            row.append(extrap)
        R.append(row)
        if i > 0 and abs(R[i][i] - R[i-1][i-1]) < tol:
            return R[i][i]
    return R[-1][-1]

# ============================
# Helper function to load C++ integration results
# ============================
def load_cpp_integral(method: str, N: int, precision: int, data_dir: str = DATA_DIR) -> float:
    """
    Load the C++ computed integral for a given method from a file.
    The file name is expected to follow the pattern:
      integral<Method>_N<N>_precision<precision>.txt
    """
    file_path = f"{data_dir}/integral{method}_N{N}_precision{precision}.txt"
    return np.loadtxt(file_path)


# ============================
# Main function
# ============================
def main():
    # Parse command-line arguments for N and precision
    parser = argparse.ArgumentParser(description="Compute integrals in Python and compare with C++ results.")
    # parser.add_argument("--datafile", type=str, required=True,
    #                     help="Path to the C++ output data file.")
    parser.add_argument("--N", type=int, required=True,
                        help="Number of sampling points used in the C++ output file (e.g., 1048577).")
    parser.add_argument("--precision", type=int, required=True,
                        help="Precision used in the C++ output file (e.g., 16).")
    args = parser.parse_args()
    
    cpp_N = args.N
    cpp_precision = args.precision
    cpp_data_file = OUTPUT_FILE_TEMPLATE.format(N=cpp_N)

    # Load full output data generated by the C++ program
    data = np.loadtxt(cpp_data_file)
    
    x_full = data[:, 0]
    fx_full = data[:, 1]

    # Compute dx from the generated data.
    dx = (x_full[-1] - x_full[0]) / (len(x_full) - 1)

    # Extract the subset corresponding to the integration interval [A, B] (i.e., [0, π/2])
    indices = np.where((x_full >= A) & (x_full <= B))[0]
    
    print(f"Number of points in the integration interval: {len(indices)}")
    
    x_subset = x_full[indices]
    fx_subset = fx_full[indices]
    
    N_AB = int(round((B - A) / dx)) + 1
    if len(x_subset) != N_AB:
        raise ValueError(f"Number of points in the integration interval ({len(x_subset)}) does not match expected count: {N_AB}.")

    # Compute the integrals using different methods
    integral_trapz = trapezoid(fx_subset, x_subset)
    integral_simpson = simpson(fx_subset, x_subset)
    f_interp = interp1d(x_subset, fx_subset, kind='cubic', fill_value="extrapolate")
    integral_romberg = romberg(f_interp, A, B, tol=ROMBERG_TOL, rtol=ROMBERG_RTOL, divmax=ROMBERG_DIVMAX)

    # Print computed integrals
    print(f"Trapezoidal Integral: {integral_trapz:.{PRINT_PRECISION}f}")
    print(f"Simpson Integral:     {integral_simpson:.{PRINT_PRECISION}f}")
    print(f"Romberg Integral:     {integral_romberg:.{PRINT_PRECISION}f}")

    # Load C++ computed integrals for comparison
    cpp_integral_trapz = load_cpp_integral("Trapz", N_AB, cpp_precision)
    cpp_integral_simpson = load_cpp_integral("Simpson", N_AB, cpp_precision)
    cpp_integral_romberg = load_cpp_integral("Romberg", N_AB, cpp_precision)

    # Compute absolute differences between Python and C++ results
    abs_diff_trapz = abs(integral_trapz - cpp_integral_trapz)
    abs_diff_simpson = abs(integral_simpson - cpp_integral_simpson)
    abs_diff_romberg = abs(integral_romberg - cpp_integral_romberg)

    # Print the absolute differences
    print(f"Absolute Difference wrt C++ (Trapz): {abs_diff_trapz:.{PRINT_PRECISION}f}")
    print(f"Absolute Difference wrt C++ (Simpson): {abs_diff_simpson:.{PRINT_PRECISION}f}")
    print(f"Absolute Difference wrt C++ (Romberg): {abs_diff_romberg:.{PRINT_PRECISION}f}")
    
    # Print a CSV row with format:
    # Language, N_AB, Trapz, Simpson, Romberg, Analytic
    print(f"py,{N_AB},{integral_trapz:.{PRINT_PRECISION}f},{integral_simpson:.{PRINT_PRECISION}f},{integral_romberg:.{PRINT_PRECISION}f},{ANALYTIC_SOLUTION:.{PRINT_PRECISION}f}")

if __name__ == '__main__':
    main()
